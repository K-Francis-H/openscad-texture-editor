<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script>
			class Canvas {
				constructor(ids={}, virtualSize){
					//check ids
					if(!ids.canvas || !ids.exportButton || !ids.clearButton || !ids.toggleGridButton){
						throw new Error("missing ids!");
					}
					this.canvas = document.getElementById(ids.canvas);
					this.REAL_WIDTH = this.canvas.width;
					this.REAL_HEIGHT = this.canvas.height;
					this.ctx = this.canvas.getContext("2d");

					this.pixw = this.REAL_WIDTH / virtualSize;
					this.pixh = this.REAL_HEIGHT / virtualSize;
					this.virtualSize = virtualSize;

					this.state = [];
					for(let i=0; i < this.virtualSize; i++){
						this.state[i] = [];
						for(let j=0; j < this.virtualSize; j++){
							this.state[i][j] = 0;
						}
					}

					this.showGrid = false;

					//for handling mousemove state
					this.mousedown = false

					this.canvas.addEventListener("mousedown", this.handleMouseDownEvent(this));
					this.canvas.addEventListener("mousemove", this.handleMouseMoveEvent(this));
					this.canvas.addEventListener("mouseup", this.handleMouseUpEvent(this));

					this.exportButton = document.getElementById(ids.exportButton);
					this.exportButton.addEventListener("click", this.handleExportButtonClick(this));

					this.clearButton = document.getElementById(ids.clearButton);
					this.clearButton.addEventListener("click", this.handleClearButtonClick(this));

					this.toggleGridButton = document.getElementById(ids.toggleGridButton);
					this.toggleGridButton.addEventListener("click", this.handleToggleGridButtonClick(this));
				
					//TODO add color select
					//associate color with a number
				}

				/*****************************
				 * CLOSURES for handling events on HTML elements.
				 * 'this' inside these elemnt event handlers refers to the HTML elements, not our Canvas class
				 * so we pass our Canvas 'this' into these closures as 'self' in order to
				 * access the fields and methods of the Canvas object
				 */

				handleExportButtonClick(self){
					return function(event){
						let code = self.exportOpenSCAD();
						console.log(code);
						//TODO paste into text area or make download .scad file
					}
				}

				handleClearButtonClick(self){
					return function(event){
						self.clear();
					}
				}

				handleToggleGridButtonClick(self){
					return function(event){
						self.showGrid = !self.showGrid;
						self.renderGrid();
						if(!self.showGrid){
							//clear and redraw the state
							self.renderFromState();
						}
					}
				}

				handleMouseDownEvent(self){
					return function(event){
						//skip if not left mouse button click
						if(event.button !== 0){
							return;
						}

						self.mousedown = true;
						let rect = event.target.getBoundingClientRect();
						let x = event.clientX - rect.left;
						let y = event.clientY - rect.top;

						let coords = self.calcVirtualPixel(x,y);
						self.paintPixel(coords[0], coords[1]);
					};
				}

				handleMouseMoveEvent(self){
					return function(event){
						if(self.mousedown){
							let rect = event.target.getBoundingClientRect();
							let x = event.clientX - rect.left;
							let y = event.clientY - rect.top;

							let coords = self.calcVirtualPixel(x,y);
							self.paintPixel(coords[0], coords[1]);
						}
					}
				}

				handleMouseUpEvent(self){
					return function(event){
						self.mousedown = false;
					}
				}

				/********************
				 * END CLOSURES
				 */

				calcVirtualPixel(xpos, ypos){
					if(xpos < 0 || ypos < 0 || xpos >= this.REAL_WIDTH || ypos >= this.REAL_HEIGHT){
						throw new Error('Coordinates ('+xpos+', '+ypos+') are out of bounds!');
					}

					let virtx = Math.floor(xpos / this.virtualSize);
					let virty = Math.floor(ypos / this.virtualSize);

					return [virtx, virty];
				}

				calcRealPixel(xpos, ypos){
					if(xpos < 0 || ypos < 0 || xpos >= this.virtualSize || ypos >= this.virtualSize){
						throw new Error('Coordinates ('+xpos+', '+ypos+') are out of bounds!');
					}

					let realx = this.pixw * xpos;
					let realy = this.pixh * ypos;
					let endx = realx + this.pixw;
					let endy = realy + this.pixh;

					return {
						startx: realx,
						starty: realy,
						endx: endx,
						endy: endy
					};
				}

				resize(virtualSize){
					this.virtualSize = virtualSize;
					this.pixw = this.REAL_WIDTH / this.virtualSize;
					this.pixh = this.REAL_HEIGHT / this.virtualSize;
				}

				clear(color="black", clearState=true){
					//reset canvas
					this.ctx.fillStyle = color;
					this.ctx.fillRect(0,0,this.REAL_WIDTH,this.REAL_HEIGHT);

					if(this.showGrid){
						this.renderGrid();
					}

					if(!clearState){
						return;
					}
					//reset state
					this.state = [];
					for(let i=0; i < this.virtualSize; i++){
						this.state[i] = [];
						for(let j=0; j < this.virtualSize; j++){
							this.state[i][j] = 0;
						}
					}
				}

				paintPixel(xpos, ypos, color="white"){
					let realx = xpos * this.pixw;
					let realy = ypos * this.pixh;

					this.ctx.fillStyle = color;
					this.ctx.fillRect(realx, realy, this.pixw, this.pixh);

					//TODO allow multiple colors to mean different heights
					if(color === "white"){
						this.state[xpos][ypos] = 1;
					}else{
						this.state[xpos][ypos] = 0;
					}
				}

				exportOpenSCAD(){
					let tex = "tex = [\n";
					for(let i=0; i < this.state.length; i++){
						let row = '\t[';
						for(let j=0; j < this.state[i].length; j++){
							row += this.state[i][j] + ",";
						}
						row += '],\n';
						tex += row;
					}
					tex += ']';
					return tex;
				}

				renderGrid(){
					if(!this.showGrid){
						return;
					}

					this.ctx.strokeStyle = "white";
					this.ctx.lineWidth = 1;

					for(let i=0; i < this.virtualSize; i++){
						for(let j=0; j < this.virtualSize; j++){
							
							//vertical lines
							this.ctx.beginPath();
							this.ctx.moveTo(i*this.pixw,j*this.pixh);
							this.ctx.lineTo(i*this.pixw,this.REAL_HEIGHT);
							this.ctx.stroke();

							//horizontal lines
							this.ctx.beginPath();
							this.ctx.moveTo(i*this.pixw,j*this.pixh);
							this.ctx.lineTo(this.REAL_WIDTH,j*this.pixh);
							this.ctx.stroke();							
						}
					}
				}

				renderFromState(){
					//clear canvas but preserve state
					this.clear("black", false);

					for(let i=0; i < this.state.length; i++){
						for(let j=0; j < this.state[i].length; j++){
							if(this.state[i][j] > 0){
								//TODO then determine which color...
								this.paintPixel(i,j);
							}
						}
					}
				}

			}//end class Canvas

			document.addEventListener("DOMContentLoaded", function(){
				const ids = {
					canvas: "canvas",
					exportButton: "export-button",
					clearButton: "clear-button",
					toggleGridButton: "show-grid"
				};
				const c = new Canvas(ids, 20);
				c.clear();

				//c.paintPixel(0,0);
				//c.paintPixel(10,10);

				//TODO add ability to resize
				//add multiple colors, heights
				//add fill bucket
				//add export button, textarea for fetching code
			});
		</script>
	</head>
	<body>
		<title>OpenSCAD Texture Editor</title>
		<canvas id="canvas" width="400" height="400">HTML5 Canvas Not Supported!</canvas>
		<div>
			<!-- TODO add color picker, color value setting (for different heights in output), canvas pixel/texture size select -->
			<button id="export-button">Export</button>
			<button id="clear-button">Clear</button>
			<button id="show-grid">Toggle Grid</button>
		</div>
	</body>
</html>