<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<script>
			class Canvas {
				constructor(ids={}, virtualSize){
					//check ids
					if(	   !ids.canvas 
						|| !ids.exportButton 
						|| !ids.clearButton 
						|| !ids.toggleGridButton 
						|| !ids.outputTextarea 
						|| !ids.toggleColorButton
						|| !ids.resizeCanvasButton){
						throw new Error("missing ids!");
					}
					this.canvas = document.getElementById(ids.canvas);
					this.REAL_WIDTH = this.canvas.width;
					this.REAL_HEIGHT = this.canvas.height;
					this.ctx = this.canvas.getContext("2d");

					this.pixw = this.REAL_WIDTH / virtualSize;
					this.pixh = this.REAL_HEIGHT / virtualSize;
					this.virtualSize = virtualSize;

					this.state = [];
					for(let i=0; i < this.virtualSize; i++){
						this.state[i] = [];
						for(let j=0; j < this.virtualSize; j++){
							this.state[i][j] = 0;
						}
					}

					this.showGrid = false;
					this.mousedown = false

					this.canvas.addEventListener("mousedown", this.handleMouseDownEvent(this));
					this.canvas.addEventListener("mousemove", this.handleMouseMoveEvent(this));
					this.canvas.addEventListener("mouseup", this.handleMouseUpEvent(this));

					this.exportButton = document.getElementById(ids.exportButton);
					this.exportButton.addEventListener("click", this.handleExportButtonClick(this));

					this.clearButton = document.getElementById(ids.clearButton);
					this.clearButton.addEventListener("click", this.handleClearButtonClick(this));

					this.toggleGridButton = document.getElementById(ids.toggleGridButton);
					this.toggleGridButton.addEventListener("click", this.handleToggleGridButtonClick(this));

					this.outputTextarea = document.getElementById(ids.outputTextarea);
				
					//TODO add color select
					//associate color with a number
					this.color = "white";
					this.toggleColorButton = document.getElementById(ids.toggleColorButton);
					this.toggleColorButton.addEventListener("click", this.handleToggleColorButton(this));

					this.resizeCanvasButton = document.getElementById(ids.resizeCanvasButton);
					this.resizeCanvasButton.addEventListener("click", this.handleResizeButtonClick(this));

					//prevents dragging mouse off of canvas and returning after mouseup
					var self = this;
					document.addEventListener("mouseover", function(event){
						self.mousedown = false;
					});
				}

				/*****************************
				 * CLOSURES for handling events on HTML elements.
				 * 'this' inside these element event handlers refers to the HTML elements, not our Canvas class
				 * so we pass our Canvas 'this' into these closures as 'self' in order to
				 * access the fields and methods of the Canvas object
				 */

				handleResizeButtonClick(self){
					return function(event){
						let divisor = window.prompt("Enter new value of N for NxN pixel grid:", self.REAL_WIDTH / self.virtualSize);
						console.log(divisor);
						if( isNaN(divisor) ){
							return; //invalid input, not going to resize canvas
						}else{
							self.resize(divisor);
							//console.log(self.virtualSize);
							//hmmm now can only color in top left quadrant when size is 40...
						}
					}
				}

				handleToggleColorButton(self){
					return function(event){
						self.color = self.color === "white" ? "black" : "white";

						//this -> toggle color button element
						this.style.color = self.color === "white" ? "black" : "white";
						this.style.backgroundColor = self.color;
					}
				}

				handleExportButtonClick(self){
					return function(event){
						let code = self.exportOpenSCAD();
						console.log(code);
						self.outputTextarea.innerText = code;

						//self.outputTextarea.select();
						//self.outputTextarea.setSelectionRange(0,99999);

						navigator.clipboard.writeText(code);
						//TODO paste into text area or make download .scad file
					}
				}

				handleClearButtonClick(self){
					return function(event){
						self.clear();
					}
				}

				handleToggleGridButtonClick(self){
					return function(event){
						self.showGrid = !self.showGrid;
						self.renderGrid();
						if(!self.showGrid){
							//clear and redraw the state
							self.renderFromState();
						}
					}
				}

				handleMouseDownEvent(self){
					return function(event){
						//skip if not left mouse button click
						if(event.button !== 0){
							return;
						}

						self.mousedown = true;
						let rect = event.target.getBoundingClientRect();
						let x = event.clientX - rect.left;
						let y = event.clientY - rect.top;

						let coords = self.calcVirtualPixel(x,y);
						self.paintPixel(coords[0], coords[1]);
					};
				}

				handleMouseMoveEvent(self){
					return function(event){
						if(self.mousedown){
							let rect = event.target.getBoundingClientRect();
							let x = event.clientX - rect.left;
							let y = event.clientY - rect.top;

							let coords = self.calcVirtualPixel(x,y);
							self.paintPixel(coords[0], coords[1]);
						}
					}
				}

				handleMouseUpEvent(self){
					return function(event){
						self.mousedown = false;
					}
				}

				/********************
				 * END CLOSURES
				 */

				calcVirtualPixel(xpos, ypos){
					if(xpos < 0 || ypos < 0 || xpos >= this.REAL_WIDTH || ypos >= this.REAL_HEIGHT){
						throw new Error('Coordinates ('+xpos+', '+ypos+') are out of bounds!');
					}

					console.log("xpos: "+xpos);
					console.log("ypos: "+ypos);
					console.log("vs: "+this.virtualSize);
					console.log("vx: "+Math.floor(xpos / this.virtualSize));
					console.log("vy: "+Math.floor(ypos / this.virtualSize));

					let virtx = Math.floor(xpos / this.pixw);
					let virty = Math.floor(ypos / this.pixh);

					return [virtx, virty];
				}

				calcRealPixel(xpos, ypos){
					if(xpos < 0 || ypos < 0 || xpos >= this.virtualSize || ypos >= this.virtualSize){
						throw new Error('Coordinates ('+xpos+', '+ypos+') are out of bounds!');
					}

					let realx = this.pixw * xpos;
					let realy = this.pixh * ypos;
					let endx = realx + this.pixw;
					let endy = realy + this.pixh;

					return {
						startx: realx,
						starty: realy,
						endx: endx,
						endy: endy
					};
				}

				resize(virtualSize){
					this.virtualSize = virtualSize;
					this.pixw = this.REAL_WIDTH / this.virtualSize;
					this.pixh = this.REAL_HEIGHT / this.virtualSize;

					this.clear();
				}

				clear(color="black", clearState=true){
					//reset canvas
					this.ctx.fillStyle = color;
					this.ctx.fillRect(0,0,this.REAL_WIDTH,this.REAL_HEIGHT);

					if(this.showGrid){
						this.renderGrid();
					}

					if(!clearState){
						return;
					}
					//reset state
					this.state = [];
					for(let i=0; i < this.virtualSize; i++){
						this.state[i] = [];
						for(let j=0; j < this.virtualSize; j++){
							this.state[i][j] = 0;
						}
					}
				}

				paintPixel(xpos, ypos){
					let realx = xpos * this.pixw;
					let realy = ypos * this.pixh;

					this.ctx.fillStyle = this.color;
					this.ctx.fillRect(realx, realy, this.pixw, this.pixh);

					//TODO allow multiple colors to mean different heights
					if(this.color === "white"){
						this.state[xpos][ypos] = 1;
					}else{
						this.state[xpos][ypos] = 0;
					}
				}

				exportOpenSCAD(){
					let tex = 'tex = [\n';
					for(let i=0; i < this.state.length; i++){
						let row = '\t[';
						for(let j=0; j < this.state[i].length; j++){
							//flip coords so we get correct orientation in OpenSCAD
							row += this.state[j][i] + ",";
						}
						row += '],\n';
						tex += row;
					}
					tex += '];';
					return tex;
				}

				renderGrid(){
					if(!this.showGrid){
						return;
					}

					this.ctx.strokeStyle = "white";
					this.ctx.lineWidth = 1;

					for(let i=0; i < this.virtualSize; i++){
						for(let j=0; j < this.virtualSize; j++){
							
							//vertical lines
							this.ctx.beginPath();
							this.ctx.moveTo(i*this.pixw,j*this.pixh);
							this.ctx.lineTo(i*this.pixw,this.REAL_HEIGHT);
							this.ctx.stroke();

							//horizontal lines
							this.ctx.beginPath();
							this.ctx.moveTo(i*this.pixw,j*this.pixh);
							this.ctx.lineTo(this.REAL_WIDTH,j*this.pixh);
							this.ctx.stroke();							
						}
					}
				}

				renderFromState(){
					//clear canvas but preserve state
					this.clear("black", false);

					//save the current color
					let currentColor = this.color;

					//repaint state
					for(let i=0; i < this.state.length; i++){
						for(let j=0; j < this.state[i].length; j++){
							if(this.state[i][j] > 0){
								//TODO then determine which color so we can have different heights
								this.color = "white";
								this.paintPixel(i,j);
							}
						}
					}

					//restore the current color
					this.color = currentColor;
				}

			}//end class Canvas

			document.addEventListener("DOMContentLoaded", function(){
				const ids = {
					canvas: "canvas",
					exportButton: "export-button",
					clearButton: "clear-button",
					toggleGridButton: "show-grid-button",
					outputTextarea: "output-textarea",
					toggleColorButton: "toggle-color-button",
					resizeCanvasButton: "resize-canvas-button"
				};
				const c = new Canvas(ids, 20);
				c.clear();

				//show the default (empty) texture array
				document.getElementById("output-textarea").innerText = c.exportOpenSCAD();
				
			});
		</script>
	</head>
	<body style="background: #FFFFDD;">
		<h1>OpenSCAD Texture Editor</h1>
		<canvas id="canvas" width="400" height="400">HTML5 Canvas Not Supported!</canvas>
		<div>
			<!-- TODO add color picker, color value setting (for different heights in output), canvas pixel/texture size select -->
			<button id="export-button" title="Generate OpenSCAD code, show preview, and copy to clipboard">Export</button>
			<button id="clear-button" title="Reset the canvas to black">Clear</button>
			<button id="show-grid-button" title="Display a grid outlining individual pixels">Toggle Grid</button>
			<button id="toggle-color-button">Toggle Color</button>
			<button id="resize-canvas-button">Resize Canvas</button>
			<h2>OpenSCAD Preview</h2>
			<div>
				<pre id="output-textarea" cols=80 rows=20 title="OpenSCAD Output Preview">
tex = [];
				</pre>
			</div>
		</div>
	</body>
</html>